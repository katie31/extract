package internal_test

import (
	"bytes"
	"io"
	"io/ioutil"
	"testing"

	"github.com/pkg/errors"
	"github.com/stretchr/testify/assert"
	"github.com/wal-g/wal-g/internal"
	"github.com/wal-g/wal-g/internal/crypto/openpgp"
	"github.com/wal-g/wal-g/testtools"
)

const (
	PrivateKeyFilePath = "../test/testdata/waleGpgKey"
)

func TestNoFilesProvided(t *testing.T) {
	buf := &testtools.NOPTarInterpreter{}
	err := internal.ExtractAll(buf, []internal.ReaderMaker{})
	assert.IsType(t, err, internal.NoFilesToExtractError{})
}

// Tests roundtrip for a tar file.
func TestTar(t *testing.T) {
	// Generate and save random bytes compare against compression-decompression cycle.
	sb := testtools.NewStrideByteReader(10)
	lr := &io.LimitedReader{
		R: sb,
		N: int64(1024),
	}
	b, err := ioutil.ReadAll(lr)

	// Copy generated bytes to another slice to make the test more robust against modifications of "b".
	bCopy := make([]byte, len(b))
	copy(bCopy, b)
	assert.NoError(t, err)

	// Make a tar in memory.
	member := &bytes.Buffer{}
	testtools.CreateTar(member, &io.LimitedReader{
		R: bytes.NewBuffer(b),
		N: int64(len(b)),
	})

	// Extract the generated tar and check that its one member is the same as the bytes generated to begin with.
	brm := &BufferReaderMaker{member, "/usr/local/file.tar"}
	buf := &testtools.BufferTarInterpreter{}
	files := []internal.ReaderMaker{brm}
	err = internal.ExtractAll(buf, files)
	if err != nil {
		t.Log(err)
	}

	assert.Equalf(t, bCopy, buf.Out, "extract: Unbundled tar output does not match input.")
}

//func TestExtractAll(t *testing.T) {
//	os.Setenv("WALE_GPG_KEY_ID", "3C19717A2B308DF0")
//	os.Setenv("WALG_DOWNLOAD_CONCURRENCY", "1")
//	defer os.Unsetenv("WALE_GPG_KEY_ID")
//	defer os.Unsetenv("WALG_DOWNLOAD_CONCURRENCY")
//	readerMaker := &testtools.FileReaderMaker{Key: "testdata/part_009.tar.zst"}
//	err := internal.ExtractAll(&testtools.NOPTarInterpreter{}, []internal.ReaderMaker {readerMaker})
//	assert.NoError(t, err)
//}

func noPassphrase() (string, bool) {
	return "", false
}

func TestDecryptAndDecompressTar_unencrypted(t *testing.T) {
	sb := testtools.NewStrideByteReader(10)
	in := &io.LimitedReader{
		R: sb,
		N: int64(1024),
	}
	b, err := ioutil.ReadAll(in)
	bCopy := make([]byte, len(b))
	copy(bCopy, b)

	compressor := GetLz4Compressor()
	compressed := internal.CompressAndEncrypt(bytes.NewReader(b), compressor, nil)

	compressedBuffer := &bytes.Buffer{}
	_, _ = compressedBuffer.ReadFrom(compressed)
	brm := &BufferReaderMaker{compressedBuffer, "/usr/local/test.tar.lz4"}

	decompressed := &bytes.Buffer{}
	err = internal.DecryptAndDecompressTar(decompressed, brm, nil)

	if err != nil {
		t.Logf("%+v\n", err)
	}
	assert.Equalf(t, bCopy, decompressed.Bytes(), "decompressed tar does not match the input")
}

func TestDecryptAndDecompressTar_encrypted(t *testing.T) {
	sb := testtools.NewStrideByteReader(10)
	in := &io.LimitedReader{
		R: sb,
		N: int64(1024),
	}

	b, err := ioutil.ReadAll(in)

	// Copy generated bytes to another slice to make the test more robust against modifications of "b".
	bCopy := make([]byte, len(b))
	copy(bCopy, b)

	crypter := openpgp.CrypterFromKeyPath(PrivateKeyFilePath, noPassphrase)

	compressor := GetLz4Compressor()
	compressed := internal.CompressAndEncrypt(bytes.NewReader(b), compressor, crypter)

	compressedBuffer, err := ioutil.ReadAll(compressed)
	brm := &BufferReaderMaker{bytes.NewBuffer(compressedBuffer), "/usr/local/test.tar.lz4"}

	decompressed := &bytes.Buffer{}
	err = internal.DecryptAndDecompressTar(decompressed, brm, crypter)

	if err != nil {
		t.Logf("%+v\n", err)
	}

	assert.Equalf(t, bCopy, decompressed.Bytes(), "decompressed tar does not match the input")
}

func TestDecryptAndDecompressTar_noCrypter(t *testing.T) {
	sb := testtools.NewStrideByteReader(10)
	in := &io.LimitedReader{
		R: sb,
		N: int64(1024),
	}

	b, err := ioutil.ReadAll(in)

	// Copy generated bytes to another slice to make the test more robust against modifications of "b".
	bCopy := make([]byte, len(b))
	copy(bCopy, b)

	crypter := openpgp.CrypterFromKeyPath(PrivateKeyFilePath, noPassphrase)

	compressor := GetLz4Compressor()
	compressed := internal.CompressAndEncrypt(bytes.NewReader(b), compressor, crypter)

	compressedBuffer, err := ioutil.ReadAll(compressed)
	brm := &BufferReaderMaker{bytes.NewBuffer(compressedBuffer), "/usr/local/test.tar.lz4"}

	decompressed := &bytes.Buffer{}
	err = internal.DecryptAndDecompressTar(decompressed, brm, nil)

	if err != nil {
		t.Logf("%+v\n", err)
	}

	assert.Error(t, err)
	originalError := errors.Cause(err)
	assert.IsType(t, internal.DecompressionError{}, originalError)
}

func TestDecryptAndDecompressTar_wrongCrypter(t *testing.T) {
	sb := testtools.NewStrideByteReader(10)
	in := &io.LimitedReader{
		R: sb,
		N: int64(1024),
	}

	b, err := ioutil.ReadAll(in)

	// Copy generated bytes to another slice to make the test more robust against modifications of "b".
	bCopy := make([]byte, len(b))
	copy(bCopy, b)

	crypter := openpgp.CrypterFromKeyPath(PrivateKeyFilePath, noPassphrase)

	compressor := GetLz4Compressor()
	compressed := internal.CompressAndEncrypt(bytes.NewReader(b), compressor, crypter)

	compressedBuffer, err := ioutil.ReadAll(compressed)
	brm := &BufferReaderMaker{bytes.NewBuffer(compressedBuffer), "/usr/local/test.tar.lzma"}

	decompressed := &bytes.Buffer{}
	err = internal.DecryptAndDecompressTar(decompressed, brm, crypter)

	assert.Error(t, err)
	originalError := errors.Cause(err)
	assert.IsType(t, internal.DecompressionError{}, originalError)
}

func TestDecryptAndDecompressTar_unknownFormat(t *testing.T) {
	sb := testtools.NewStrideByteReader(10)
	in := &io.LimitedReader{
		R: sb,
		N: int64(1024),
	}

	b, err := ioutil.ReadAll(in)

	// Copy generated bytes to another slice to make the test more robust against modifications of "b".
	bCopy := make([]byte, len(b))
	copy(bCopy, b)

	brm := &BufferReaderMaker{bytes.NewBuffer(b), "/usr/local/test.some_unsupported_file_format"}

	decompressed := &bytes.Buffer{}
	err = internal.DecryptAndDecompressTar(decompressed, brm, nil)

	if err != nil {
		t.Logf("%+v\n", err)
	}

	assert.Error(t, err)
	assert.IsType(t, internal.UnsupportedFileTypeError{}, err)
}

func TestDecryptAndDecompressTar_uncompressed(t *testing.T) {
	sb := testtools.NewStrideByteReader(10)
	in := &io.LimitedReader{
		R: sb,
		N: int64(1024),
	}
	b, err := ioutil.ReadAll(in)
	bCopy := make([]byte, len(b))
	copy(bCopy, b)

	compressed := internal.CompressAndEncrypt(bytes.NewReader(b), nil, nil)

	compressedBuffer := &bytes.Buffer{}
	_, _ = compressedBuffer.ReadFrom(compressed)
	brm := &BufferReaderMaker{compressedBuffer, "/usr/local/test.tar"}

	decompressed := &bytes.Buffer{}
	err = internal.DecryptAndDecompressTar(decompressed, brm, nil)

	if err != nil {
		t.Logf("%+v\n", err)
	}
	assert.Equalf(t, bCopy, decompressed.Bytes(), "decompressed tar does not match the input")
}

// Used to mock files in memory.
type BufferReaderMaker struct {
	Buf *bytes.Buffer
	Key string
}

func (b *BufferReaderMaker) Reader() (io.ReadCloser, error) { return ioutil.NopCloser(b.Buf), nil }
func (b *BufferReaderMaker) Path() string                   { return b.Key }
